<?xml version="1.0" encoding="utf-8"?>
<search>
  
  
    
    <entry>
      <title><![CDATA[html-trick1]]></title>
      <url>http://bupt2014140518.github.io/2016/01/14/html-trick1/</url>
      <content type="html"><![CDATA[<p>html-css-javascript使用过程中进行总结<br><a id="more"></a></p>
<h3 id="1-_psd文件进行切图完成对html设计">1. psd文件进行切图完成对html设计</h3><blockquote>
<ul>
<li>已经准备好的psd文件；</li>
<li>打开之后，用矩形选择工具，进行选择；之后按ctrl+shift+c合并复制，再按ctrl+N，完成新建画布；再按ctrl+v将刚选择的图片黏贴；最后按ctrl+s保存为jpg、png等。</li>
</ul>
</blockquote>
<p><strong><em>参考</em></strong><br><a href="http://sixrevisions.com/tutorials/web-development-tutorials/psdhtml-conversion-elegant-and-simple-css3-web-layout/" target="_blank" rel="external">psd切图1</a><br><a href="http://sixrevisions.com/tutorials/photoshop-tutorials/make-an-elegant-and-simple-blog-web-layout-using-photoshop/" target="_blank" rel="external">psd切图2</a></p>
<h3 id="2-_li_click">2. li click</h3><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="title">li</span> <span class="attribute">onclick</span>=<span class="value">"location.href='http://example';"</span>&gt;</span> ... <span class="tag">&lt;/<span class="title">li</span>&gt;</span></span><br></pre></td></tr></table></figure>
]]></content>
    </entry>
    
    <entry>
      <title><![CDATA[word-图片自动编号]]></title>
      <url>http://bupt2014140518.github.io/2015/12/17/word-%E5%9B%BE%E7%89%87%E8%87%AA%E5%8A%A8%E7%BC%96%E5%8F%B7/</url>
      <content type="html"><![CDATA[<p>论文中经常要用到图片插入、修改的操作，如何利用word使之更加便利! It is time to use more powerful tool~<br><img src="http://7xn88r.com1.z0.glb.clouddn.com/Bagan,%20Burma4.jpg" alt="Bagan"><br><a id="more"></a><br>针对此功能，主要分为三步：</p>
<ol>
<li>插入题注——首先在要入编号的图片后，点击“引用”-》“插入题注”，弹出对话窗口。<br>选择“新建标签”，命名为“图1-”，点击“确定”；</li>
<li>再在需要添加描述的文本中，点击“引用”-》“交叉引用”，弹出对话窗口。<br>选择合适的引用“图1-”，选择正确的引用标注，点击“插入”；</li>
<li>以后每次添加新的图片，在图片后点击“引用”-》“插入题注”，会自动生成接着上次的编号，直接点击插入即可。</li>
</ol>
<p><strong><em>Note</em></strong><br>对于更改图片顺序和图片序号的直接，全选、右键、更新域即可。<br><strong><em>参见</em></strong><br><a href="http://www.111cn.net/office/word/51842.htm" target="_blank" rel="external">http://www.111cn.net/office/word/51842.htm</a><br><a href="http://blog.sciencenet.cn/blog-344887-543229.html" target="_blank" rel="external">http://blog.sciencenet.cn/blog-344887-543229.html</a></p>
]]></content>
    </entry>
    
    <entry>
      <title><![CDATA[我的web之路-AngularJS]]></title>
      <url>http://bupt2014140518.github.io/2015/12/09/%E6%88%91%E7%9A%84web%E4%B9%8B%E8%B7%AF-AngularJS/</url>
      <content type="html"><![CDATA[<p>前端学习之AngularJS——最近一直在<a href="https://www.codecademy.com/" target="_blank" rel="external">Codecademy</a>学习，获益匪浅！<br><img src="http://7xn88r.com1.z0.glb.clouddn.com/Great%20Smoky%20Mountains,%20U.S6.jpg" alt="Mountains"><br><a id="more"></a></p>
<h3 id="概述">概述</h3><p>AngularJS是一个javascript web开发框架，旨在让网站开发变得更加高效，其主要还是基于MVC框架来实现。</p>
]]></content>
    </entry>
    
    <entry>
      <title><![CDATA[我的web之路-jQuery]]></title>
      <url>http://bupt2014140518.github.io/2015/12/08/%E6%88%91%E7%9A%84web%E4%B9%8B%E8%B7%AF-jQuery/</url>
      <content type="html"><![CDATA[<p>前端学习之jQuery——最近一直在<a href="https://www.codecademy.com/" target="_blank" rel="external">Codecademy</a>学习，获益匪浅！<br><img src="http://7xn88r.com1.z0.glb.clouddn.com/Great%20Smoky%20Mountains,%20U.S6.jpg" alt="Mountains"><br><a id="more"></a></p>
<h3 id="概述">概述</h3><p>jQuery是一个web前端库，也可以说是javascript的一个外包，它通过选择器的机制完成对网页的动态实现(<a href="http://jquery.com/" target="_blank" rel="external">详见</a>)。</p>
<h3 id="主要内容">主要内容</h3><ol>
<li>Events. Respond to user interactions.</li>
<li>DOM Manipulation. Modify HTML elements on the page.</li>
<li>Effects. Add animations.</li>
</ol>
<p><strong><em>一般模式</em></strong>：<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">$(<span class="built_in">document</span>).ready(<span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">    <span class="keyword">do</span> sth;</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure></p>
<h3 id="常用event&amp;effect">常用event&amp;effect</h3><ol>
<li>click / hover /dblclick (mouse常用)</li>
<li>addClass /removeClass /append /preAppend /remove /css /animate (element常用)</li>
<li>keydown / (keyboard常用)</li>
<li>UI (丰富的动画效果)</li>
</ol>
]]></content>
    </entry>
    
    <entry>
      <title><![CDATA[我的github]]></title>
      <url>http://bupt2014140518.github.io/2015/12/02/%E6%88%91%E7%9A%84github/</url>
      <content type="html"><![CDATA[<p>简述关于构建github应用——hexo博客&amp;其他项目<br><img src="http://7xn88r.com1.z0.glb.clouddn.com/Yosemite,%20U.S..jpg" alt="Yosemite"><br><a id="more"></a></p>
<h2 id="0-概述">0.概述</h2><p>本文的主要内容是简介github的使用，主要从两方面：username.git.io和project(gh-pages)来创建应用。</p>
<h3 id="1-搭建hexo静态博客">1.搭建hexo静态博客</h3><p>该部分主要是基于username.git.io来创建独立博客。主要分为三阶段：</p>
<ol>
<li>准备环境：Node.js&amp;Git&amp;Hexo</li>
<li>github创建应用： 在这里是创建username.git.io项目（最后网站地址：<a href="http://username.github.io）" target="_blank" rel="external">http://username.github.io）</a></li>
<li>hexo配置、上传: 网站基本配置&amp;主题配置</li>
</ol>
<p><strong><em>详见</em></strong>：<a href="http://blog.fens.me/hexo-blog-github/" target="_blank" rel="external">参考1</a> <a href="https://xuanwo.org/2015/03/26/hexo-intor/" target="_blank" rel="external">参考2</a><br><strong><em>demo</em></strong>：<a href="http://bupt2014140518.github.io/">little blog</a></p>
<h3 id="2-搭建项目">2.搭建项目</h3><p>该部分主要是基于gh-pages来创建项目或者应用。</p>
<ol>
<li>建立项目：git clone github.com/user/repository.git</li>
<li><p>切换分支，发布应用（访问地址形如：<a href="https://username.github.io/projectname）" target="_blank" rel="external">https://username.github.io/projectname）</a></p>
<p>git clone <a href="https://github.com/bupt2014140518/tit.git" target="_blank" rel="external">https://github.com/bupt2014140518/tit.git</a><br>git checkout –orphan gh-pages<br>git pull origin gh-pages<br>git commit -a -m “First pages commit<br>git push origin gh-pages</p>
</li>
</ol>
<p><strong><em>详见</em></strong>：<a href="https://help.github.com/articles/creating-project-pages-manually/" target="_blank" rel="external">参考1</a><br><strong><em>demo</em></strong>： <a href="http://bupt2014140518.github.io/tit/">tit</a></p>
]]></content>
    </entry>
    
    <entry>
      <title><![CDATA[我的web之路-javaScript]]></title>
      <url>http://bupt2014140518.github.io/2015/11/26/%E6%88%91%E7%9A%84web%E4%B9%8B%E8%B7%AF-javaScript/</url>
      <content type="html"><![CDATA[<p>前端学习之javaScript——《JavaScript DOM 编程艺术 第二版》<br><img src="http://7xn88r.com1.z0.glb.clouddn.com/San%20Francisco,%20U.S12.jpg" alt="San Francisco"><br><a id="more"></a></p>
<p>###第一部分——DOM简介<br>前三章主要可以总结如下：<br>主要介绍基础：JavaScript语法、DOM简介。</p>
<p>DOM（Document Object Model/Map）可以看成是JavaScript的一个标准，如同c++14是c++的标准一样</p>
<p>###第二部分——DOM简单实践<br>4-5章主要以案例的形式，介绍DOM的相关特点：</p>
<ol>
<li>平稳退化：确保网页在没有JavaScript的情况下也能正常工作</li>
<li>分离JavaScript：把网页的结构和JavaScript脚本的动作行为分开</li>
<li>向后兼容：确保老版本的浏览器不会因为你的JavaScript脚本而死掉</li>
<li>性能考虑：确保脚本执行的性能最优</li>
</ol>
<p>###第三部分——概述<br>网页的三层：</p>
<ol>
<li>结构层 html</li>
<li>样式层 css</li>
<li>行为层 javascript &amp; dom</li>
</ol>
<p>###第四部分<br>丰富强大的库<br>jquery<br>prototype</p>
]]></content>
    </entry>
    
    <entry>
      <title><![CDATA[我的web之路-css]]></title>
      <url>http://bupt2014140518.github.io/2015/11/16/%E6%88%91%E7%9A%84web%E4%B9%8B%E8%B7%AF-css/</url>
      <content type="html"><![CDATA[<p>《精通CSS 高级web标准解决方案 第2版》<br><img src="http://7xn88r.com1.z0.glb.clouddn.com/San%20Francisco,%20U.S11.jpg" alt="San Francisco"><br><a id="more"></a><br>正文</p>
]]></content>
    </entry>
    
    <entry>
      <title><![CDATA[读书-计算机网络]]></title>
      <url>http://bupt2014140518.github.io/2015/11/13/%E8%AF%BB%E4%B9%A6-%E3%80%8A%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E3%80%8B/</url>
      <content type="html"><![CDATA[<p>摘要<br><img src="http://7xn88r.com1.z0.glb.clouddn.com/San%20Francisco,%20U.S31.jpg" alt="San Francisco"><br><a id="more"></a><br>正文</p>
]]></content>
    </entry>
    
    <entry>
      <title><![CDATA[Rudy-追梦赤子心]]></title>
      <url>http://bupt2014140518.github.io/2015/11/03/Rudy-%E8%BF%BD%E6%A2%A6%E8%B5%A4%E5%AD%90%E5%BF%83/</url>
      <content type="html"><![CDATA[<p>这是一个关于不放弃的电影，名字叫《Rudy》,在看的过程中非常感动，感动的是Rudy那永远不放弃的心，让我印象深刻的主要是他的朋友说的一句话:</p>
<blockquote>
<p>Having dreams is what makes life tolerable.——梦想让生活得以忍受。</p>
</blockquote>
<p>还有当Rudy终于考进圣母大学的时候的一句话（当时我也是热泪盈眶）：</p>
<blockquote>
<p>Thanks god!</p>
</blockquote>
<p><img src="http://7xn88r.com1.z0.glb.clouddn.com/Great%20Smoky%20Mountains,%20U.S.2.jpg" alt="Great Smoky Mountains"><br><a id="more"></a><br>正文</p>
]]></content>
    </entry>
    
    <entry>
      <title><![CDATA[Super Girl]]></title>
      <url>http://bupt2014140518.github.io/2015/11/01/Super-Girl/</url>
      <content type="html"><![CDATA[<p><img src="http://7xn88r.com1.z0.glb.clouddn.com/Niagara%20Falls3.jpg" alt="Niagara"><br>美剧《Super Girl》的一段很美的话~</p>
<p><audio src="http://7xn88r.com1.z0.glb.clouddn.com/Supergirl.S01E01.720p.HDTV.X264-DIMENSION_clip.mp3" controls="controls"></audio><br><a id="more"></a><br>There is no correct path in life.<br>生活没有绝对正确的道路。<br>You will lose your way many times.<br>你会数次迷失方向。<br>What’s important, is that you find your way back to the brave girl you always were.<br>然而重要的是，你要找回那个勇敢的自己。<br>Be wise,be strong and always be true to yourself.<br>要明理，要坚强，要永远忠于自己。</p>
]]></content>
    </entry>
    
    <entry>
      <title><![CDATA[剑指offer-栈的操作]]></title>
      <url>http://bupt2014140518.github.io/2015/10/26/%E5%89%91%E6%8C%87offer-%E6%A0%88%E7%9A%84%E6%93%8D%E4%BD%9C/</url>
      <content type="html"><![CDATA[<p>主要是关于栈的相关操作，注意先进后出，出栈，入栈，顶部元素等~<br><img src="http://7xn88r.com1.z0.glb.clouddn.com/Neuschwanstein%20Castle,%20German11.jpg" alt="Castle"><br><a id="more"></a></p>
<h3 id="问题描述1——栈内求min(利用额外空间)">问题描述1——栈内求min(利用额外空间)</h3><p>定义栈的数据结构，请在该类型中实现一个能够得到栈最小元素的min函数。</p>
<h3 id="代码">代码</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span><br><span class="line">* 1.dataStack为存储数据的栈，minStack为存储最小值的栈；</span><br><span class="line">* 2.push的时候将value值与minStack中的top值比较，小则minStack push value，大则push top值</span><br><span class="line">*/</span></span><br><span class="line"><span class="keyword">class</span> Solution &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">stack</span>&lt;<span class="keyword">int</span>&gt; dataStack, minStack;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">push</span><span class="params">(<span class="keyword">int</span> value)</span> </span>&#123;</span><br><span class="line">        dataStack.push(value);</span><br><span class="line">        <span class="keyword">if</span> (minStack.empty()) &#123;</span><br><span class="line">            minStack.push(value);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span>&#123;</span><br><span class="line">            <span class="keyword">int</span> min = minStack.top();</span><br><span class="line">            value&lt;=min?minStack.push(value):minStack.push(min);</span><br><span class="line">        &#125;</span><br><span class="line">         </span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">pop</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        dataStack.pop();</span><br><span class="line">        minStack.pop();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">top</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span>  dataStack.top();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">min</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> minStack.top();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>]]></content>
    </entry>
    
    <entry>
      <title><![CDATA[剑指offer-顺时针打印矩阵]]></title>
      <url>http://bupt2014140518.github.io/2015/10/23/%E5%89%91%E6%8C%87offer-%E9%A1%BA%E6%97%B6%E9%92%88%E6%89%93%E5%8D%B0%E7%9F%A9%E9%98%B5/</url>
      <content type="html"><![CDATA[<p>主要是用画图的思路，来解决问题（==顺时针打印矩阵==）<br><img src="http://7xn88r.com1.z0.glb.clouddn.com/Paris,%20France11.jpg" alt="Paris"><br><a id="more"></a></p>
<h3 id="问题描述">问题描述</h3><p>输入一个矩阵，按照从外向里以顺时针的顺序依次打印出每一个数字，例如，如果输入如下矩阵： 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 则依次打印出数字1,2,3,4,8,12,16,15,14,13,9,5,6,7,11,10.</p>
<hr>
<h3 id="代码">代码</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*解题思路：顺时针打印就是按圈数循环打印，一圈包含两行或者两列，在打印的时候会出现某一圈中只包含一行，要判断从左向右打印和从右向左打印的时候是否会出现重复打印，同样只包含一列时，要判断从上向下打印和从下向上打印的时候是否会出现重复打印的情况*/</span></span><br><span class="line"><span class="keyword">class</span> Solution &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; printMatrix(<span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; &gt; matrix) &#123;</span><br><span class="line">        <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;res;</span><br><span class="line">        res.clear();</span><br><span class="line">        <span class="keyword">int</span> row=matrix.size();<span class="comment">//行数</span></span><br><span class="line">        <span class="keyword">int</span> collor=matrix[<span class="number">0</span>].size();<span class="comment">//列数</span></span><br><span class="line">        <span class="comment">//计算打印的圈数</span></span><br><span class="line">        <span class="keyword">int</span> circle=((row&lt;collor?row:collor)-<span class="number">1</span>)/<span class="number">2</span>+<span class="number">1</span>;<span class="comment">//圈数</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;circle;i++)&#123;</span><br><span class="line">            <span class="comment">//从左向右打印</span></span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> j=i;j&lt;collor-i;j++)</span><br><span class="line">                res.push_back(matrix[i][j]);         </span><br><span class="line">            <span class="comment">//从上往下的每一列数据</span></span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> k=i+<span class="number">1</span>;k&lt;row-i;k++)</span><br><span class="line">                res.push_back(matrix[k][collor-<span class="number">1</span>-i]);</span><br><span class="line">            <span class="comment">//判断是否会重复打印(从右向左的每行数据)</span></span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> m=collor-i-<span class="number">2</span>;(m&gt;=i)&amp;&amp;(row-i-<span class="number">1</span>!=i);m--)</span><br><span class="line">                res.push_back(matrix[row-i-<span class="number">1</span>][m]);</span><br><span class="line">            <span class="comment">//判断是否会重复打印(从下往上的每一列数据)</span></span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> n=row-i-<span class="number">2</span>;(n&gt;i)&amp;&amp;(collor-i-<span class="number">1</span>!=i);n--)</span><br><span class="line">                res.push_back(matrix[n][i]);&#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
]]></content>
    </entry>
    
    <entry>
      <title><![CDATA[剑指offer-二叉树相关操作]]></title>
      <url>http://bupt2014140518.github.io/2015/10/20/%E5%89%91%E6%8C%87offer-%E4%BA%8C%E5%8F%89%E6%A0%91%E7%9B%B8%E5%85%B3%E6%93%8D%E4%BD%9C/</url>
      <content type="html"><![CDATA[<p>主要是对于二叉树的操作：判断是否是子树；遍历等等；由于二叉树的特点，递归是普遍适用于解决树的几乎所有的问题~<br><img src="http://7xn88r.com1.z0.glb.clouddn.com/Paris,%20France4.jpg" alt="Paris"><br><a id="more"></a></p>
<h3 id="问题描述1——子树判断">问题描述1——子树判断</h3><p>输入两颗二叉树A，B，判断B是不是A的子结构。<br><strong><em>递归</em></strong></p>
<h3 id="代码1">代码1</h3><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">//&#26641;&#23450;&#20041;&#10;struct TreeNode &#123;&#10;&#9;int val;&#10;&#9;struct TreeNode *left;&#10;&#9;struct TreeNode *right;&#10;&#9;TreeNode(int x) :&#10;&#9;&#9;&#9;val(x), left(NULL), right(NULL) &#123;&#10;&#9;&#125;&#10;&#125;;&#10;class Solution &#123;&#10;public:&#10;    bool isSubtree(TreeNode* pRoot1, TreeNode* pRoot2)&#123;&#10;        if(pRoot2 == NULL) return true;&#10;        if(pRoot1 == NULL) return false;&#10;        if(pRoot1-&#62;val == pRoot2-&#62;val)&#10;            return isSubtree(pRoot1-&#62;left,pRoot2-&#62;left) &#38;&#38; isSubtree(pRoot1-&#62;right,pRoot2-&#62;right);&#10;        else&#10;            return false;         &#10;    &#125;&#10;     &#10;public:&#10;    bool HasSubtree(TreeNode* pRoot1, TreeNode* pRoot2)&#10;    &#123;&#10;        if(pRoot1 == NULL || pRoot2 == NULL) return false;&#10;        return isSubtree(pRoot1,pRoot2) || HasSubtree(pRoot1-&#62;left,pRoot2) || HasSubtree(pRoot1-&#62;right,pRoot2);&#10;    &#125;&#10;&#125;;</span><br></pre></td></tr></table></figure>
<h3 id="问题描述2——树的镜像">问题描述2——树的镜像</h3><p>操作给定的二叉树，将其变换为源二叉树的镜像。<br>二叉树的镜像定义：<br>         源二叉树<br>            8<br>           /  \<br>          6   10<br>         / \  /  \<br>        5  7 9  11<br>        镜像二叉树<br>            8<br>           /  \<br>          10   6<br>         / \  / \<br>        11 9 7   5</p>
<h3 id="代码2">代码2</h3><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">struct TreeNode &#123;&#10;&#9;int val;&#10;&#9;struct TreeNode *left;&#10;&#9;struct TreeNode *right;&#10;&#9;TreeNode(int x) :&#10;&#9;&#9;&#9;val(x), left(NULL), right(NULL) &#123;&#10;&#9;&#125;&#10;&#125;;&#10;class Solution &#123;&#10;public:&#10;    void Mirror(TreeNode *pRoot) &#123;&#10;&#9;&#9;if(pRoot)&#123;&#10;            TreeNode *tmp = pRoot-&#62;left;&#10;            pRoot-&#62;left = pRoot-&#62;right;&#10;            pRoot-&#62;right= tmp;&#10;            if(pRoot-&#62;right)&#123;&#10;                 Mirror(pRoot-&#62;right);&#10;            &#125;&#10;            if(pRoot-&#62;left)&#123;&#10;                 Mirror(pRoot-&#62;left);&#10;            &#125;&#10;        &#125;&#10;    &#125;&#10;&#125;;</span><br></pre></td></tr></table></figure>
]]></content>
    </entry>
    
    <entry>
      <title><![CDATA[改变从态度开始]]></title>
      <url>http://bupt2014140518.github.io/2015/10/14/%E6%94%B9%E5%8F%98%E4%BB%8E%E6%80%81%E5%BA%A6%E5%BC%80%E5%A7%8B/</url>
      <content type="html"><![CDATA[<blockquote class="blockquote-center">决定结果的正是我们在处理表面上微不足道、枯燥乏味，<br>而且不用麻烦的细枝末节时所采取的谨慎小心的态度。————澳大利亚科学家 贝弗里奇</blockquote>

<p><img src="http://7xn88r.com1.z0.glb.clouddn.com/Lake%20Tekapo,%20New%20Zealand1.jpg" alt="Lake"><br><a id="more"></a><br>   今天比较忙，自己感觉上是忙，忙整理hexo，我的博客，下午被高老师去修改申请国家奖学金的申请表，被吐槽了一下午~<br>虽然略有失落，但的确是这样，我自己经常是比较大大咧咧，不够细心，不够认真，高老师在给我指导的过程中，标点符号的注意、不要出现大段的空白句、尽量不要用太不谦虚的字眼（比如形容自己优异。。。高老师说也是要了解别人的心理，人家容易反感~）。<br>   无论工作还是生活，其实都需要我们认真的去对待，《士兵突击》里的许三多说过:</p>
<blockquote>
<p>好好活，做有意义的——许三多</p>
</blockquote>
]]></content>
    </entry>
    
    <entry>
      <title><![CDATA[剑指offer-链表操作]]></title>
      <url>http://bupt2014140518.github.io/2015/10/13/%E5%89%91%E6%8C%87offer-%E9%93%BE%E8%A1%A8%E6%93%8D%E4%BD%9C/</url>
      <content type="html"><![CDATA[<p>主要针对链表的操作~<br><img src="http://7xn88r.com1.z0.glb.clouddn.com/Grand%20Teton%20National%20Park,%20U.S..jpg" alt="Grand Teton"><br><a id="more"></a></p>
<h3 id="问题描述1">问题描述1</h3><p>输入一个链表，输出该链表中倒数第k个结点。<br><strong><em>分析1</em></strong></p>
<ol>
<li>最优：设定两个指针，让第一个指针和第二个指针都指向头结点，然后再让第一个指针走(k-1)步，到达第k个节点。<br>然后两个指针同时往后移动，当第一个结点到达末尾的时候，第二个结点所在位置就是倒数第k个节点了；</li>
<li>较简单：首先算出链表的总长度n，然后返回第n-k个。</li>
</ol>
<h3 id="代码1">代码1</h3><p><strong><em>思路11</em></strong><br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> ListNode &#123;</span><br><span class="line">    <span class="keyword">int</span> val;</span><br><span class="line">    ListNode next = null;</span><br><span class="line"></span><br><span class="line">    ListNode(<span class="keyword">int</span> val) &#123;</span><br><span class="line">        <span class="keyword">this</span>.val = val;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> Solution &#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> ListNode <span class="title">FindKthToTail</span><span class="params">(ListNode head,<span class="keyword">int</span> k)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(head==null||k&lt;=<span class="number">0</span>)&#123;</span><br><span class="line">            <span class="keyword">return</span> null;</span><br><span class="line">        &#125;</span><br><span class="line">        ListNode pre=head;</span><br><span class="line">        ListNode last=head;       </span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;k;i++)&#123;</span><br><span class="line">            <span class="keyword">if</span>(pre.next!=null)&#123;</span><br><span class="line">                pre=pre.next;</span><br><span class="line">            &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                <span class="keyword">return</span> null;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">while</span>(pre.next!=null)&#123;</span><br><span class="line">            pre = pre.next;</span><br><span class="line">            last=last.next;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> last;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p><strong><em>思路12</em></strong><br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> ListNode &#123;</span><br><span class="line">    <span class="keyword">int</span> val;</span><br><span class="line">    ListNode next = null;</span><br><span class="line"></span><br><span class="line">    ListNode(<span class="keyword">int</span> val) &#123;</span><br><span class="line">        <span class="keyword">this</span>.val = val;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">class</span> Solution &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">ListNode* <span class="title">FindKthToTail</span><span class="params">(ListNode* pListHead, <span class="keyword">unsigned</span> <span class="keyword">int</span> k)</span> </span>&#123;</span><br><span class="line">        ListNode* pp = pListHead;</span><br><span class="line">        <span class="keyword">int</span> n = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">while</span>(pp != <span class="literal">NULL</span>) &#123;</span><br><span class="line">            n++;</span><br><span class="line">            pp = pp-&gt;next;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(n &lt; k or k==<span class="number">0</span> or pp==<span class="literal">NULL</span>) <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">        <span class="keyword">int</span> i = <span class="number">0</span>;</span><br><span class="line">        pp = pListHead;</span><br><span class="line">        <span class="keyword">while</span>(pp != <span class="literal">NULL</span> &amp;&amp; ++i &lt; (n-k+<span class="number">1</span>)) pp = pp-&gt;next;</span><br><span class="line">        <span class="keyword">return</span> pp;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></p>
<h3 id="问题2">问题2</h3><p>输入一个链表，反转链表后，输出链表的所有元素。<br><strong><em>头插法（三个指针轮换）</em></strong></p>
<h3 id="代码2">代码2</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">struct</span> ListNode &#123;</span><br><span class="line">    <span class="keyword">int</span> val;</span><br><span class="line">    <span class="keyword">struct</span> ListNode *next;</span><br><span class="line">    ListNode(<span class="keyword">int</span> x) :</span><br><span class="line">            val(x), next(<span class="literal">NULL</span>) &#123;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">class</span> Solution &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">ListNode* <span class="title">ReverseList</span><span class="params">(ListNode* pHead)</span> </span>&#123;</span><br><span class="line">        ListNode* h = <span class="literal">NULL</span>;</span><br><span class="line">		<span class="keyword">if</span>(pHead)&#123;</span><br><span class="line">			<span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">		&#125;</span><br><span class="line">        <span class="keyword">for</span>(ListNode* p = pHead; p; )&#123;</span><br><span class="line">            ListNode* tmp = p -&gt; next;</span><br><span class="line">            p -&gt; next = h;</span><br><span class="line">            h = p;</span><br><span class="line">            p = tmp;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> h;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h3 id="问题3">问题3</h3><p>输入两个单调递增的链表，输出两个链表合成后的链表，当然我们需要合成后的链表满足单调不减规则。<br><strong><em>注意tmp的作用</em></strong></p>
<h3 id="代码3">代码3</h3><p><strong><em>非递归方法</em></strong><br><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line">struct ListNode &#123;</span><br><span class="line">	int val;</span><br><span class="line">	struct ListNode *next;</span><br><span class="line">	ListNode(int x) :</span><br><span class="line">			val(x), next(NULL) &#123;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;;</span><br><span class="line">class Solution &#123;</span><br><span class="line">public:</span><br><span class="line">    ListNode* Merge(ListNode* pHead1, ListNode* pHead2)</span><br><span class="line">    &#123;</span><br><span class="line">         ListNode tmp(20), *p = &amp;tmp;</span><br><span class="line">        while(pHead1 || pHead2)&#123;</span><br><span class="line">            if(!pHead2 || (pHead1 &amp;&amp; pHead1 -&gt; val &lt;= pHead2 -&gt; val))&#123;</span><br><span class="line">                p -&gt; next = pHead1;</span><br><span class="line">                pHead1 = pHead1 -&gt; next;</span><br><span class="line">            &#125;</span><br><span class="line">            else&#123;</span><br><span class="line">                p -&gt; next = pHead2;</span><br><span class="line">                pHead2 = pHead2 -&gt; next;</span><br><span class="line">            &#125;</span><br><span class="line">            p = p -&gt; next;</span><br><span class="line">        &#125;</span><br><span class="line">        return tmp.next;</span><br><span class="line">    &#125;</span><br><span class="line">   </span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></p>
<p><strong><em>递归方法</em></strong><br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">struct</span> ListNode &#123;</span><br><span class="line">	<span class="keyword">int</span> val;</span><br><span class="line">	<span class="keyword">struct</span> ListNode *next;</span><br><span class="line">	ListNode(<span class="keyword">int</span> x) :</span><br><span class="line">			val(x), next(<span class="literal">NULL</span>) &#123;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">class</span> Solution &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">ListNode* <span class="title">Merge</span><span class="params">(ListNode* pHead1, ListNode* pHead2)</span></span><br><span class="line">    </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(list1==null)</span><br><span class="line">			<span class="keyword">return</span> list2;</span><br><span class="line">		<span class="keyword">else</span> <span class="keyword">if</span>(list2==null)</span><br><span class="line">			<span class="keyword">return</span> list1;</span><br><span class="line">		ListNode mergeHead=null;</span><br><span class="line">		<span class="keyword">if</span>(list1.val&lt;list2.val)&#123;</span><br><span class="line">			mergeHead=list1;</span><br><span class="line">			mergeHead.next=Merge(list1.next, list2);</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">else</span>&#123;</span><br><span class="line">			mergeHead=list2;</span><br><span class="line">			mergeHead.next=Merge(list1, list2.next);</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">return</span> mergeHead;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></p>
]]></content>
    </entry>
    
    <entry>
      <title><![CDATA[My sweet darling GrandMa]]></title>
      <url>http://bupt2014140518.github.io/2015/10/12/My-sweet-darling-GrandMa/</url>
      <content type="html"><![CDATA[<p><img src="http://7xn88r.com1.z0.glb.clouddn.com/Tuscany,%20Italy6.jpg" alt="Italy"><br><a id="more"></a><br>看了《What We Did on Our Holiday》,很感动，想起了我的姥姥~<br>我姥姥是一位很自强的女人，她经常唠叨，经常对我说对别人好，别人就对你好，但不要被别人欺负；<br>她经常骂我，特别是我在吃饭的时候看电视，还有小时候那些淘气的时候；她陪伴我从出生的第二天早上一直到现在，<br>她很好，虽然身体不大好，但是她吃的很多，这是我高兴的地方~<br>想说的还有很多。。。<br>然而最重要的就是：我爱我姥姥~</p>
<video src="http://7xn88r.com1.z0.glb.clouddn.com/What.We.Did.on.Our.Holiday.2014.1080p.BluRay.X264-AMIABLE_clip.mp4" width="320" height="240" controls autobuffer=""></video> ]]></content>
    </entry>
    
    <entry>
      <title><![CDATA[剑指offer-数组重整]]></title>
      <url>http://bupt2014140518.github.io/2015/10/12/%E5%89%91%E6%8C%87offer-%E6%95%B0%E7%BB%84%E9%87%8D%E6%95%B4/</url>
      <content type="html"><![CDATA[<p>考查：代码的完整性，主要用于快排，插排的思想解决实际问题~<br><img src="http://7xn88r.com1.z0.glb.clouddn.com/Salar%20de%20Uyuni,%20Bolivia2.jpg" alt="Salar"><br><a id="more"></a></p>
<h3 id="问题描述">问题描述</h3><p>输入一个整数数组，实现一个函数来调整该数组中数字的顺序，使得所有的奇数位于数组的前半部分，所有的偶数位于位于数组的后半部分，<br>并保证奇数和奇数，偶数和偶数之间的相对位置不变。<br><strong><em>主要有三种思路</em></strong></p>
<ol>
<li>插排的思路</li>
<li>快排的思路（不保证奇数与奇数的顺序）</li>
<li>最简单的用数组复制的思路]</li>
</ol>
<h3 id="代码">代码</h3><p><strong>思路1 插排</strong><br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">reOrderArray</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; &amp;<span class="built_in">array</span>)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;<span class="built_in">array</span>.length;i++)&#123;</span><br><span class="line">            <span class="keyword">if</span>(<span class="built_in">array</span>[i]%<span class="number">2</span>==<span class="number">1</span>)&#123;</span><br><span class="line">                <span class="keyword">int</span> temp=<span class="built_in">array</span>[i];</span><br><span class="line">                <span class="keyword">int</span> j=i-<span class="number">1</span>;</span><br><span class="line">                <span class="keyword">while</span>(j&gt;=<span class="number">0</span>&amp;&amp;<span class="built_in">array</span>[j]%<span class="number">2</span>==<span class="number">0</span>)&#123;</span><br><span class="line">                    <span class="built_in">array</span>[j+<span class="number">1</span>]=<span class="built_in">array</span>[j];</span><br><span class="line">                    j--;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="built_in">array</span>[j+<span class="number">1</span>]=temp;</span><br><span class="line">            &#125;            </span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure></p>
<p><strong>思路2 最简单的复制</strong><br>奇数在a数组，偶数在b数组，然后再讲array的数组重新插入a&amp;b<br><strong>思路3 快排（无序）</strong><br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">reOrderArray</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; &amp;<span class="built_in">array</span>)</span> </span>&#123;</span><br><span class="line">      <span class="keyword">int</span> i=<span class="number">0</span>;</span><br><span class="line">      <span class="keyword">int</span> j=<span class="built_in">array</span>.length-<span class="number">1</span>;</span><br><span class="line">      <span class="keyword">while</span>(i&lt;j)&#123;</span><br><span class="line">          <span class="keyword">while</span>(i&lt;j&amp;&amp;<span class="built_in">array</span>[i]%<span class="number">2</span>==<span class="number">1</span>)&#123;</span><br><span class="line">              i++;</span><br><span class="line">          &#125;</span><br><span class="line">          <span class="keyword">while</span>(i&lt;j&amp;&amp;<span class="built_in">array</span>[j]%<span class="number">2</span>==<span class="number">0</span>)&#123;</span><br><span class="line">              j--;</span><br><span class="line">          &#125;</span><br><span class="line">          <span class="keyword">int</span> temp=<span class="built_in">array</span>[j];</span><br><span class="line">          <span class="built_in">array</span>[j]=<span class="built_in">array</span>[i];</span><br><span class="line">          <span class="built_in">array</span>[i]=temp;</span><br><span class="line">      &#125;</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure></p>
]]></content>
    </entry>
    
    <entry>
      <title><![CDATA[Song-Beauty in the World]]></title>
      <url>http://bupt2014140518.github.io/2015/10/11/Song-Beauty-in-the-World/</url>
      <content type="html"><![CDATA[<p>电影《Paper Planes》纸飞机的片尾曲~sweet song<br><img src="http://7xn88r.com1.z0.glb.clouddn.com/Antelope%20Canyon,%20U.S2.jpg" alt="Antelope"><br><a id="more"></a></p>
<p><audio src="http://7xn88r.com1.z0.glb.clouddn.com/Paper.Planes.2014.BluRay.720p.DTS.x264-MTeam_clip.mp3" controls="controls"></audio></p>
<h4 id="歌词：">歌词：</h4><p>I know you’re fed up<br>我知道你已经受够了<br>Like a lead up for us<br>向我们的领导一样<br>All they talk about is<br>他们说的都是<br>What is going down?<br>发生了什么<br>What’s been messed up for us?<br>我们出了什么差错<br>When I look around I see blue skies<br>当我环顾四周的时候我看见蓝色的天空<br>I see butterflies for us<br>我看见蝴蝶<br>Listen to the sound and lose it<br>听到声音然后失去了<br>Its sweet music and dance with me<br>和着美妙的音乐跳舞<br>There is beauty in the world<br>世界上有美好的事物<br>So much beauty in the world<br>世界还有这么多美好<br>Always beauty in the world<br>世界总是美好的<br>So much beauty in the world<br>世界如此美好<br>Shake your booty boys and girls for the beauty in the world<br>男孩女孩们为了世界的美好摇摆吧<br>Pick your diamond pick your pearl there is beauty in the world<br>挑选你的钻石你的珍珠吧，世界很美好<br>All together now<br>都一起吧<br>We need more lovin’<br>我们需要更多的爱<br>We need more money, they say<br>他们说我们需要更多的钱<br>Change is gonna come<br>将要有改变了<br>Like the weather<br>像天气一样<br>They say forever<br>他们说永远<br>They say<br>他们说<br>When they’re in between<br>当他们在中间时<br>Notice the blue skies<br>注意到蓝天<br>Notice the butterflies<br>主意到蝴蝶<br>Notice me<br>注意到我<br>Stop and smell the flowers<br>停下来闻花香<br>And lose it the sweet music and dance with me<br>迷失自己和我在音乐中跳舞<br>There is beauty in the world<br>世界上有美好的事物<br>So much beauty in the world<br>世界还有这么多美好<br>Always beauty in the world<br>世界总是美好的<br>So much beauty in the world<br>世界如此美好<br>Shake your booty boys and girls for the beauty in the world<br>男孩女孩们为了世界的美好摇摆吧<br>Pick your diamond pick your pearl there is beauty in the world<br>挑选你的钻石你的珍珠吧，世界很美好<br>All together now<br>都一起吧<br>Heya throw your hands up and holla<br>举起手摇摆吧<br>Throw your hands up and holla<br>举起手摇摆<br>When you don’t know what to do<br>当你不知道怎么办时候<br>Don’t know if you’ll make it through<br>不知道你能否坚持度过<br>Remember god is giving you beauty in the world<br>记住上帝给你世界上美好的东西<br>So love (Beauty in the world)<br>所以爱吧<br>Yeah love (Beauty in the world)<br>爱吧<br>There is beauty in the world (Beauty in the world)<br>世界上有很多美好<br>Beauty in the world (Beauty in the world)<br>世界很美好<br>Shake your booty boys and girls (Boys and Girls)<br>男孩女孩起舞吧<br>All the beauty in the world (Beauty in the world)<br>世界很美好<br>Pick your diamond pick your pearl (Pick your pearl)<br>挑选你的钻石和珠宝<br>There is beauty in the world (Beauty in the world)<br>世界有很多美好<br>All together now<br>大家一起<br>Yeah love 耶亲爱的<br>Yeah love耶亲爱的<br>Oh love亲爱的<br>All together now<br>大家一起<br>Hey baby when I’m looking at you<br>亲爱的当我看你的时候<br>I know it’s fact is true<br>我知道这是真的<br>There is hope for love<br>爱还有希望<br>There is beauty in the world<br>世界很美好<br>Hey baby when I’m looking at you<br>亲爱的当我看你的时候<br>I know it’s fact is true<br>我知道这是真的<br>There is hope for love<br>爱还有希望<br>There is beauty in the world<br>世界很美好</p>
]]></content>
    </entry>
    
    <entry>
      <title><![CDATA[剑指offer-位运算]]></title>
      <url>http://bupt2014140518.github.io/2015/10/11/%E5%89%91%E6%8C%87offer-%E4%BD%8D%E8%BF%90%E7%AE%97/</url>
      <content type="html"><![CDATA[<p>只要考查位运算，将十进制转化为二进制，包括负数（补码表示）<br><img src="http://7xn88r.com1.z0.glb.clouddn.com/Antelope%20Canyon,%20U.S..jpg" alt="Antelope"><br><a id="more"></a></p>
<h3 id="问题描述">问题描述</h3><p>输入一个整数，输出该数二进制表示中1的个数。其中负数用补码表示。</p>
<h3 id="代码">代码</h3><p><strong>解答1</strong><br>如果一个整数不为0，那么这个整数至少有一位是1。如果我们把这个整数减1，那么原来处在整数最右边的1就会变为0，<br>原来在1后面的所有的0都会变成1(如果最右边的1后面还有0的话)。其余所有位将不会受到影响。<br>举个例子：一个二进制数1100，从右边数起第三位是处于最右边的一个1。减去1后，第三位变成0，它后面的两位0变成了1，<br>而前面的1保持不变，因此得到的结果是1011.我们发现减1的结果是把最右边的一个1开始的所有位都取反了。<br>这个时候如果我们再把原来的整数和减去1之后的结果做与运算，从原来整数最右边一个1那一位开始所有位都会变成0。<br>如1100&amp;1011=1000.也就是说，把一个整数减去1，再和原整数做与运算，会把该整数最右边一个1变成0.<br>那么一个整数的二进制有多少个1，<br>就可以进行多少次这样的操作。<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span>  <span class="title">NumberOf1</span><span class="params">(<span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">       <span class="keyword">int</span> count = <span class="number">0</span>;</span><br><span class="line">       <span class="keyword">while</span>(n!= <span class="number">0</span>)&#123;</span><br><span class="line">           count++;</span><br><span class="line">           n = n &amp; (n - <span class="number">1</span>);</span><br><span class="line">        &#125;</span><br><span class="line">       <span class="keyword">return</span> count;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p><strong>解答2</strong><br>用1（1自身左移运算，其实后来就不是1了）和n的每位进行位与，来判断1的个数<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span>  <span class="title">NumberOf1</span><span class="params">(<span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">       <span class="keyword">int</span> count = <span class="number">0</span>;</span><br><span class="line">       <span class="keyword">int</span> flag = <span class="number">1</span>;</span><br><span class="line">       <span class="keyword">while</span> (flag != <span class="number">0</span>) &#123;</span><br><span class="line">           <span class="keyword">if</span> ((n &amp; flag) != <span class="number">0</span>) &#123;</span><br><span class="line">               count++;</span><br><span class="line">           &#125;</span><br><span class="line">           flag = flag &lt;&lt; <span class="number">1</span>;</span><br><span class="line">       &#125;</span><br><span class="line">       <span class="keyword">return</span> count;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
]]></content>
    </entry>
    
    <entry>
      <title><![CDATA[剑指offer-斐波那契数列应用-跳台阶&&矩形覆盖]]></title>
      <url>http://bupt2014140518.github.io/2015/10/10/%E5%89%91%E6%8C%87offer-%E6%96%90%E6%B3%A2%E9%82%A3%E5%A5%91%E6%95%B0%E5%88%97%E5%BA%94%E7%94%A8-%E8%B7%B3%E5%8F%B0%E9%98%B6/</url>
      <content type="html"><![CDATA[<p>斐波那契数列的应用，递归和动态规划（循环）的灵活使用~<br><img src="http://7xn88r.com1.z0.glb.clouddn.com/Horseshoe%20Bend,%20U.S1..jpg" alt="Horseshoe"><br><a id="more"></a></p>
<h3 id="问题描述：">问题描述：</h3><p>一只青蛙一次可以跳上1级台阶，也可以跳上2级。求该青蛙跳上一个n级的台阶总共有多少种跳法。<br><strong><em>分析</em></strong>：<br>1.假设当有n个台阶时假设有f(n)种走法。<br>2.青蛙最后一步要么跨1个台阶要么跨2个台阶。<br>3.当最后一步跨1个台阶时即之前有n-1个台阶，根据1的假设即n-1个台阶有f(n-1)种走法。<br>4.当最后一步跨1个台阶时即之前有n-2个台阶，根据1的假设即n-2个台阶有f(n-2 )种走法。<br>5.显然n个台阶的走法等于前两种情况的走法之和即f(n)=f(n-1)+f(n-2)。<br>6.找出递推公式后要找公式出口，即当n为1、2时的情况，显然n=1时f(1)等于1，f(2)等于2。</p>
<h3 id="代码">代码</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//***递归法***</span></span><br><span class="line"> <span class="function"><span class="keyword">int</span> <span class="title">jumpFloor</span><span class="params">(<span class="keyword">int</span> number)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> count = <span class="number">0</span>;</span><br><span class="line">	<span class="keyword">if</span>(number &lt;= <span class="number">0</span>)&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    &#125;    </span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span>(number == <span class="number">1</span>)&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">    &#125;      </span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span>(number == <span class="number">2</span>)&#123;</span><br><span class="line">         <span class="keyword">return</span> <span class="number">2</span>;</span><br><span class="line">    &#125;     </span><br><span class="line">    <span class="keyword">else</span>&#123;</span><br><span class="line">        count = jumpFloor(number-<span class="number">1</span>) + jumpFloor(number-<span class="number">2</span>);</span><br><span class="line">        <span class="keyword">return</span> count;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//***动态规划法（循环）***</span></span><br><span class="line"> <span class="function"><span class="keyword">int</span> <span class="title">jumpFloor</span><span class="params">(<span class="keyword">int</span> number)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(number &lt; <span class="number">3</span>) </span><br><span class="line">		returnnumber;    </span><br><span class="line">	<span class="keyword">int</span> two = <span class="number">2</span>;</span><br><span class="line">	<span class="keyword">int</span> one = <span class="number">1</span>;</span><br><span class="line">	<span class="keyword">int</span> result = <span class="number">0</span>;</span><br><span class="line">	<span class="keyword">for</span>(inti = <span class="number">3</span>; i &lt;= number; ++i)</span><br><span class="line">	&#123;</span><br><span class="line">		result = one + two;</span><br><span class="line">		two = one;</span><br><span class="line">		one = result;</span><br><span class="line">		 </span><br><span class="line">	&#125; </span><br><span class="line">	<span class="keyword">return</span> result;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//另外一种思路：***排列组合算法***</span></span><br><span class="line"><span class="comment">//问题解析：设共跳x个1级台阶，y个2级台阶，可推出x+2y=n =&gt; x=n-2y,</span></span><br><span class="line"><span class="comment">//最终问题为对n-2y个一级台阶与y个2级台阶排列组合，即C(n-y,y)。</span></span><br><span class="line"><span class="comment">//y的范围：y&gt;=0&amp;&amp;y&lt;=(n/2) x的范围：x&gt;=0&amp;&amp;x&lt;=0。</span></span><br><span class="line"> <span class="comment">//求排列组合数</span></span><br><span class="line"> <span class="function"><span class="keyword">int</span> <span class="title">com</span><span class="params">(<span class="keyword">int</span> m,<span class="keyword">int</span> n)</span></span>&#123;  </span><br><span class="line">    <span class="keyword">int</span> i = m;  </span><br><span class="line">    <span class="keyword">int</span> j; </span><br><span class="line">    <span class="keyword">int</span> sum=<span class="number">1</span>; </span><br><span class="line">    <span class="keyword">for</span>(j = <span class="number">0</span>;j &lt; n;j++,i--)&#123; </span><br><span class="line">        sum = sum *i / (j+<span class="number">1</span>);  </span><br><span class="line">    &#125; </span><br><span class="line">    <span class="keyword">return</span> sum;</span><br><span class="line"> &#125; </span><br><span class="line"> <span class="function"><span class="keyword">int</span> <span class="title">jumpFloor</span><span class="params">(<span class="keyword">int</span> number)</span></span>&#123; </span><br><span class="line">    <span class="keyword">int</span> two; <span class="comment">/*跳两级台阶的次数*/</span> </span><br><span class="line">    <span class="keyword">int</span> count = <span class="number">0</span>; </span><br><span class="line">    <span class="keyword">for</span>(two = <span class="number">0</span>;two&lt;= (number/<span class="number">2</span>);two ++)&#123; </span><br><span class="line">        count += com(number-two,two);</span><br><span class="line">    &#125; </span><br><span class="line">    <span class="keyword">return</span> count;</span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure>
<h3 id="升级方式的跳台阶；">升级方式的跳台阶；</h3><p>一只青蛙一次可以跳上1级台阶，也可以跳上2级……它也可以跳上n级。求该青蛙跳上一个n级的台阶总共有多少种跳法。</p>
<h3 id="归纳分析">归纳分析</h3><p>因为n级台阶，第一步有n种跳法：跳1级、跳2级、到跳n级<br>跳1级，剩下n-1级，则剩下跳法是f(n-1)<br>跳2级，剩下n-2级，则剩下跳法是f(n-2)<br>所以f(n)=f(n-1)+f(n-2)+…+f(1)<br>因为f(n-1)=f(n-2)+f(n-3)+…+f(1)<br>所以f(n)=2*f(n-1);<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">jumpFloorII</span><span class="params">(<span class="keyword">int</span> number)</span> </span>&#123;</span><br><span class="line">	<span class="keyword">if</span>(number&lt;=<span class="number">0</span>)&#123;</span><br><span class="line">           <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">       &#125;</span><br><span class="line">       <span class="keyword">else</span> <span class="keyword">if</span>(number==<span class="number">1</span>)&#123;</span><br><span class="line">           <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">       &#125;</span><br><span class="line">       <span class="keyword">else</span> <span class="keyword">if</span>(number&gt;<span class="number">1</span>)&#123;</span><br><span class="line">           <span class="keyword">return</span> <span class="number">2</span>*jumpFloorII(number-<span class="number">1</span>);</span><br><span class="line">       &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<h3 id="另一应用——矩形覆盖">另一应用——矩形覆盖</h3><p><strong><em>题目描述</em></strong><br>我们可以用2<em>1的小矩形横着或者竖着去覆盖更大的矩形。请问用n个2</em>1的小矩形无重叠地覆盖一个2*n的大矩形，总共有多少种方法？<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">rectCover</span><span class="params">(<span class="keyword">int</span> number)</span> </span>&#123;</span><br><span class="line">	<span class="keyword">if</span>(number &lt; <span class="number">1</span>)&#123;</span><br><span class="line">          <span class="keyword">return</span> <span class="number">1</span>; </span><br><span class="line">       &#125;</span><br><span class="line">       <span class="keyword">else</span> <span class="keyword">if</span>(number == <span class="number">1</span> or number == <span class="number">2</span>)&#123;</span><br><span class="line">           <span class="keyword">return</span> number;</span><br><span class="line">       &#125;</span><br><span class="line">       <span class="keyword">else</span>&#123;</span><br><span class="line">           <span class="keyword">return</span> rectCover(number-<span class="number">1</span>)+rectCover(number-<span class="number">2</span>);</span><br><span class="line">       &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
]]></content>
    </entry>
    
    <entry>
      <title><![CDATA[剑指offer-斐波那契数列]]></title>
      <url>http://bupt2014140518.github.io/2015/10/10/%E5%89%91%E6%8C%87offer-%E6%96%90%E6%B3%A2%E9%82%A3%E5%A5%91%E6%95%B0%E5%88%97/</url>
      <content type="html"><![CDATA[<p>借助斐波那契数列来比较递归和动态规划，该题看似很适合斐波那契数列，但递归会造成栈溢出，用动态规划（循环）会好点~<br><img src="http://7xn88r.com1.z0.glb.clouddn.com/Horseshoe%20Bend,%20U.S..jpg" alt="Horseshoe"><br><a id="more"></a></p>
<h3 id="问题描述：">问题描述：</h3><p>大家都知道斐波那契数列，现在要求输入一个整数n，请你输出斐波那契数列的第n项，有时间和内存限制。（注意：n从第0项开始的）</p>
<h3 id="代码">代码</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line"><span class="preprocessor">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">Fibonacci</span><span class="params">(<span class="keyword">int</span> n)</span> </span><br><span class="line"></span>&#123;</span><br><span class="line">	<span class="keyword">int</span> arr[<span class="number">2</span>] = &#123;<span class="number">0</span>,<span class="number">1</span>&#125;;</span><br><span class="line">	<span class="keyword">if</span> (n &lt; <span class="number">0</span>)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">else</span> <span class="keyword">if</span> (n == <span class="number">0</span>) </span><br><span class="line">	&#123;</span><br><span class="line">		<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">else</span> <span class="keyword">if</span> (n == <span class="number">1</span>) </span><br><span class="line">	&#123;</span><br><span class="line">		<span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">else</span></span><br><span class="line">	&#123;</span><br><span class="line">		<span class="comment">////递归(如果输入是个很大的n,是会溢出)</span></span><br><span class="line">		<span class="comment">//return Fibonacci(n-1) + Fibonacci(n-2);</span></span><br><span class="line">		<span class="comment">//循环(动态规划)</span></span><br><span class="line">		<span class="keyword">int</span> i = arr[<span class="number">0</span>], j = arr[<span class="number">1</span>],t;</span><br><span class="line">		<span class="keyword">for</span> (<span class="keyword">int</span> k = <span class="number">2</span>; k &lt;= n;k++)</span><br><span class="line">		&#123;</span><br><span class="line">			t = i + j;</span><br><span class="line">			i = j;</span><br><span class="line">			j = t;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">return</span> t;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">	<span class="comment">// your code goes here</span></span><br><span class="line">	<span class="keyword">int</span> n;</span><br><span class="line">	<span class="built_in">cin</span> &gt;&gt; n;</span><br><span class="line">	<span class="built_in">cout</span> &lt;&lt; Fibonacci(n) &lt;&lt; endl;</span><br><span class="line">	system(<span class="string">"Pause"</span>);</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    </entry>
    
    <entry>
      <title><![CDATA[剑指offer-链表、树、队列]]></title>
      <url>http://bupt2014140518.github.io/2015/10/07/%E5%89%91%E6%8C%87offer-%E9%93%BE%E8%A1%A8%E3%80%81%E6%A0%91%E3%80%81%E9%98%9F%E5%88%97/</url>
      <content type="html"><![CDATA[<p>输入一个链表，从尾到头打印链表每个节点的值。<br><img src="http://7xn88r.com1.z0.glb.clouddn.com/Santorini,%20Greece.jpg" alt="Greece"><br><a id="more"></a></p>
<h3 id="问题描述-链表">问题描述-链表</h3><p>输入一个链表，从尾到头打印链表每个节点的值。</p>
<h3 id="代码">代码</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">struct</span> ListNode &#123;</span><br><span class="line">        <span class="keyword">int</span> val;</span><br><span class="line">        <span class="keyword">struct</span> ListNode *next;</span><br><span class="line">        ListNode(<span class="keyword">int</span> x) :</span><br><span class="line">              val(x), next(<span class="literal">NULL</span>) &#123;</span><br><span class="line">        &#125;</span><br><span class="line">  &#125;;</span><br><span class="line"><span class="keyword">class</span> Solution &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; printListFromTailToHead(<span class="keyword">struct</span> ListNode* head) &#123;</span><br><span class="line">        <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; v;</span><br><span class="line">        <span class="keyword">while</span>(head != <span class="literal">NULL</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            v.insert(v.begin(),head-&gt;val);<span class="comment">//insert就是倒序插入，从前插入</span></span><br><span class="line">            head = head-&gt;next;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//reverse(v.begin(),v.end());//适用于push_bach</span></span><br><span class="line">        <span class="keyword">return</span> v;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h3 id="问题描述-树">问题描述-树</h3><p>输入某二叉树的前序遍历和中序遍历的结果，请重建出该二叉树。假设输入的前序遍历和中序遍历的结果中都不含重复的数字。例如输入前序遍历序列{1,2,4,7,3,5,6,8}和中序遍历序列{4,7,2,1,5,3,8,6}，则重建二叉树并返回。</p>
<h3 id="代码-1">代码</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#include &lt;iostream&gt;</span></span><br><span class="line"><span class="comment">#include &lt;vector&gt;</span></span><br><span class="line">using namespace std;</span><br><span class="line">//Definition <span class="keyword">for</span> binary tree</span><br><span class="line">struct TreeNode &#123;</span><br><span class="line">	int val;</span><br><span class="line">	TreeNode *left;</span><br><span class="line">	TreeNode *right;</span><br><span class="line">	TreeNode(int x) : val(x), left(NULL), right(NULL) &#123;&#125;</span><br><span class="line">&#125;;</span><br><span class="line">class Solution &#123;</span><br><span class="line">public:</span><br><span class="line">	struct TreeNode* reConstructBinaryTree(vector&lt;int&gt; pre, vector&lt;int&gt; <span class="keyword">in</span>) &#123;</span><br><span class="line">		int <span class="keyword">in</span>Count = in.size();</span><br><span class="line">		<span class="keyword">if</span> (<span class="keyword">in</span>Count == <span class="number">0</span>)</span><br><span class="line">			<span class="built_in">return</span> NULL;</span><br><span class="line">		vector&lt;int&gt; left_pre, right_pre, left_<span class="keyword">in</span>, right_<span class="keyword">in</span>;</span><br><span class="line">		//创建根节点，根节点肯定是前序遍历的第一个数</span><br><span class="line">		TreeNode* Head = new TreeNode(pre[<span class="number">0</span>]);</span><br><span class="line">		//找到中序遍历根节点所在位置,存放于变量root中</span><br><span class="line">		int root = <span class="number">0</span>;</span><br><span class="line">		<span class="keyword">for</span> (int i = <span class="number">0</span>; i&lt;<span class="keyword">in</span>Count; i++)</span><br><span class="line">		&#123;</span><br><span class="line">			<span class="keyword">if</span> (<span class="keyword">in</span>[i] == pre[<span class="number">0</span>])</span><br><span class="line">			&#123;</span><br><span class="line">				root = i;</span><br><span class="line">				<span class="built_in">break</span>;</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">		//对于中序遍历，根节点左边的节点位于二叉树的左边，根节点右边的节点位于二叉树的右边</span><br><span class="line">		//利用上述这点，对二叉树节点进行归并</span><br><span class="line">		<span class="keyword">for</span> (int i = <span class="number">0</span>; i&lt;root; i++)</span><br><span class="line">		&#123;</span><br><span class="line">			left_in.push_back(<span class="keyword">in</span>[i]);</span><br><span class="line">			left_pre.push_back(pre[i + <span class="number">1</span>]);//前序第一个为根节点</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">for</span> (int i = root + <span class="number">1</span>; i&lt;<span class="keyword">in</span>Count; i++)</span><br><span class="line">		&#123;</span><br><span class="line">			right_in.push_back(<span class="keyword">in</span>[i]);</span><br><span class="line">			right_pre.push_back(pre[i]);</span><br><span class="line">		&#125;</span><br><span class="line">		//和shell排序的思想类似，取出前序和中序遍历根节点左边和右边的子树</span><br><span class="line">		//递归，再对其进行上述所有步骤，即再区分子树的左、右子子数，直到叶节点</span><br><span class="line">		Head-&gt;left = reConstructBinaryTree(left_pre, left_<span class="keyword">in</span>);</span><br><span class="line">		Head-&gt;right = reConstructBinaryTree(right_pre, right_<span class="keyword">in</span>);</span><br><span class="line">		<span class="built_in">return</span> Head;</span><br><span class="line">	&#125;</span><br><span class="line">	struct TreeNode* reConstructBinaryTree2(vector&lt;int&gt; <span class="keyword">in</span>, vector&lt;int&gt; post) &#123;</span><br><span class="line">		int <span class="keyword">in</span>Count = in.size();</span><br><span class="line">		<span class="keyword">if</span> (<span class="keyword">in</span>Count == <span class="number">0</span>)</span><br><span class="line">			<span class="built_in">return</span> NULL;</span><br><span class="line">		vector&lt;int&gt; left_post, right_post, left_<span class="keyword">in</span>, right_<span class="keyword">in</span>;</span><br><span class="line">		//创建根节点，根节点肯定是后序遍历的最后一个数</span><br><span class="line">		TreeNode* Head = new TreeNode(post[<span class="keyword">in</span>Count-<span class="number">1</span>]);</span><br><span class="line">		//找到中序遍历根节点所在位置,存放于变量root中</span><br><span class="line">		int root = <span class="number">0</span>;</span><br><span class="line">		<span class="keyword">for</span> (int i = <span class="number">0</span>; i &lt; <span class="keyword">in</span>Count; i++)</span><br><span class="line">		&#123;</span><br><span class="line">			<span class="keyword">if</span> (<span class="keyword">in</span>[i] == post[<span class="keyword">in</span>Count - <span class="number">1</span>])</span><br><span class="line">			&#123;</span><br><span class="line">				root = i;</span><br><span class="line">				<span class="built_in">break</span>;</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">		//对于中序遍历，根节点左边的节点位于二叉树的左边，根节点右边的节点位于二叉树的右边</span><br><span class="line">		//利用上述这点，对二叉树节点进行归并</span><br><span class="line">		<span class="keyword">for</span> (int i = <span class="number">0</span>; i &lt; root; i++)</span><br><span class="line">		&#123;</span><br><span class="line">			left_in.push_back(<span class="keyword">in</span>[i]);</span><br><span class="line">			left_post.push_back(post[i]);//前序第一个为根节点</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">for</span> (int i = root + <span class="number">1</span>; i &lt; <span class="keyword">in</span>Count; i++)</span><br><span class="line">		&#123;</span><br><span class="line">			right_in.push_back(<span class="keyword">in</span>[i]);</span><br><span class="line">			right_post.push_back(post[i-<span class="number">1</span>]);</span><br><span class="line">		&#125;</span><br><span class="line">		//和shell排序的思想类似，取出后序和中序遍历根节点左边和右边的子树</span><br><span class="line">		//递归，再对其进行上述所有步骤，即再区分子树的左、右子子数，直到叶节点</span><br><span class="line">		Head-&gt;left = reConstructBinaryTree2(left_<span class="keyword">in</span>,left_post);</span><br><span class="line">		Head-&gt;right = reConstructBinaryTree2(right_<span class="keyword">in</span>,right_post);</span><br><span class="line">		<span class="built_in">return</span> Head;</span><br><span class="line">	&#125;</span><br><span class="line">	//由树得到后序遍历</span><br><span class="line">	void getPostTraverse(TreeNode * node)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="keyword">if</span> (node) &#123;</span><br><span class="line">			getPostTraverse(node-&gt;left);</span><br><span class="line">			getPostTraverse(node-&gt;right);</span><br><span class="line">			cout &lt;&lt; node-&gt;val &lt;&lt; <span class="string">" "</span>;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	//由树得到中序遍历</span><br><span class="line">	void getInTraverse(TreeNode * node)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="keyword">if</span> (node) &#123;</span><br><span class="line">			getInTraverse(node-&gt;left);</span><br><span class="line">			cout &lt;&lt; node-&gt;val &lt;&lt; <span class="string">" "</span>;</span><br><span class="line">			getInTraverse(node-&gt;right);</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	//由树得到前序遍历</span><br><span class="line">	void getPreTraverse(TreeNode * node)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="keyword">if</span> (node) &#123;</span><br><span class="line">			cout &lt;&lt; node-&gt;val &lt;&lt; <span class="string">" "</span>;</span><br><span class="line">			getPreTraverse(node-&gt;left);</span><br><span class="line">			getPreTraverse(node-&gt;right);</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;;</span><br><span class="line">void <span class="function"><span class="title">main</span></span>()</span><br><span class="line">&#123;</span><br><span class="line">	vector&lt;int&gt; vv1,vv2;</span><br><span class="line">	int i=<span class="number">0</span>,j=<span class="number">0</span>;</span><br><span class="line">	char a;</span><br><span class="line">	<span class="keyword">while</span> (cin&gt;&gt;i)</span><br><span class="line">	&#123;</span><br><span class="line">		vv1.push_back(i);</span><br><span class="line">		a= cin.get();</span><br><span class="line">		<span class="keyword">if</span> (a == <span class="string">'\n'</span>)</span><br><span class="line">			<span class="built_in">break</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">while</span> (cin &gt;&gt; j)</span><br><span class="line">	&#123;</span><br><span class="line">		vv2.push_back(j);</span><br><span class="line">		a = cin.get();</span><br><span class="line">		<span class="keyword">if</span> (a == <span class="string">'\n'</span>)</span><br><span class="line">			<span class="built_in">break</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	Solution ss;</span><br><span class="line">	//TreeNode *tt = ss.reConstructBinaryTree(vv1,vv2);</span><br><span class="line">	//ss.getPostTraverse(tt);</span><br><span class="line">	//cout &lt;&lt; endl;</span><br><span class="line">	//ss.getPreTraverse(tt);</span><br><span class="line">	//cout &lt;&lt; endl;</span><br><span class="line">	//ss.getInTraverse(tt);</span><br><span class="line">	//cout &lt;&lt; endl;</span><br><span class="line">	TreeNode *tt2 = ss.reConstructBinaryTree2(vv1, vv2);</span><br><span class="line">	ss.getPreTraverse(tt2);</span><br><span class="line">	cout &lt;&lt; endl;</span><br><span class="line">	system(<span class="string">"Pause"</span>);</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="Note">Note</h4><p>（1）可以由前序、中序和中序、后序，求出第三种序列；但是前序和后序不可以；<br>（2）前序第一个是root节点，中序找到root所在位置，左是root的左子树组，右是右子树组；同理，后序最后一个是root节点，剩下的和前面类似，递归最终求出第三种序列。</p>
<h3 id="问题描述-对列">问题描述-对列</h3><p>用两个栈来实现一个队列，完成队列的Push和Pop操作。 队列中的元素为int类型。</p>
<h3 id="代码-2">代码</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line">class Solution</span><br><span class="line">&#123;</span><br><span class="line">public:</span><br><span class="line">    void push(int node) &#123;</span><br><span class="line">        stack1.push(node);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    int <span class="function"><span class="title">pop</span></span>() &#123;</span><br><span class="line">        <span class="keyword">if</span>(stack2.empty())</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span>(stack1.empty())</span><br><span class="line">            &#123;</span><br><span class="line">                cout &lt;&lt; <span class="string">"List is empty"</span> &lt;&lt; endl;</span><br><span class="line">                <span class="built_in">return</span> -<span class="number">1</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span>&#123;</span><br><span class="line">                <span class="keyword">while</span>(!stack1.empty())</span><br><span class="line">                &#123;</span><br><span class="line">                   stack2.push(stack1.top());</span><br><span class="line">                   stack1.pop();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;       </span><br><span class="line">        &#125;</span><br><span class="line">        int a = stack2.top();</span><br><span class="line">        stack2.pop();</span><br><span class="line">        <span class="built_in">return</span> a;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">private:</span><br><span class="line">    stack&lt;int&gt; stack1;</span><br><span class="line">    stack&lt;int&gt; stack2;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h4 id="Note-1">Note</h4><p>（1）栈是先进后出；队列是先进先出。</p>
]]></content>
    </entry>
    
    <entry>
      <title><![CDATA[剑指offer-数组查找]]></title>
      <url>http://bupt2014140518.github.io/2015/10/07/%E5%89%91%E6%8C%87offer-%E6%95%B0%E7%BB%84%E6%9F%A5%E6%89%BE/</url>
      <content type="html"><![CDATA[<p>主要是运用c++ vector实现二维数组查找~<br><img src="http://7xn88r.com1.z0.glb.clouddn.com/Tuscany,%20Italy6.jpg" alt="Italy"><br><a id="more"></a></p>
<h3 id="问题描述">问题描述</h3><p>在一个二维数组中，每一行都按照从左到右递增的顺序排序，每一列都按照从上到下递增的顺序排序。请完成一个函数，输入这样的一个二维数组和一个整数，判断数组中是否含有该整数。</p>
<h3 id="代码">代码</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br></pre></td><td class="code"><pre><span class="line"><span class="preprocessor">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="preprocessor">#<span class="keyword">include</span> <span class="string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">findItem_quick</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt; <span class="built_in">array</span>,<span class="keyword">int</span> target)</span><span class="comment">//从每行的最右边开始，减少比较次数</span></span><br><span class="line"></span>&#123;</span><br><span class="line">	<span class="keyword">if</span> (<span class="built_in">array</span>.empty())</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="keyword">return</span>	<span class="literal">false</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">int</span> row = <span class="built_in">array</span>.size();</span><br><span class="line">	<span class="keyword">int</span> col = <span class="built_in">array</span>[<span class="number">0</span>].size();</span><br><span class="line">	<span class="keyword">int</span> i=<span class="number">0</span>, j=col-<span class="number">1</span>;</span><br><span class="line">	<span class="keyword">while</span> (i&lt;row &amp;&amp; j&gt;=<span class="number">0</span>)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="keyword">if</span> (<span class="built_in">array</span>[i][j] == target)</span><br><span class="line">		&#123;</span><br><span class="line">			<span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">else</span> <span class="keyword">if</span> (<span class="built_in">array</span>[i][j] &gt; target)</span><br><span class="line">		&#123;</span><br><span class="line">			j--;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">else</span> <span class="keyword">if</span> (<span class="built_in">array</span>[i][j] &lt; target)</span><br><span class="line">		&#123;</span><br><span class="line">			i++;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">findItem</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt; <span class="built_in">array</span>, <span class="keyword">int</span> target)</span><span class="comment">//中规中矩</span></span><br><span class="line"></span>&#123;</span><br><span class="line">	<span class="keyword">if</span> (<span class="built_in">array</span>.empty())</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="keyword">return</span>	<span class="literal">false</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">int</span> row = <span class="built_in">array</span>.size();</span><br><span class="line">	<span class="keyword">int</span> col = <span class="built_in">array</span>[<span class="number">0</span>].size();</span><br><span class="line">	<span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; row; i++)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; col; j++)</span><br><span class="line">		&#123;</span><br><span class="line">			<span class="keyword">if</span> (<span class="built_in">array</span>[i][j] == target)</span><br><span class="line">			&#123;</span><br><span class="line">				<span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">main</span><span class="params">()</span></span><br><span class="line"></span>&#123;</span><br><span class="line">	<span class="keyword">int</span> a[<span class="number">2</span>][<span class="number">4</span>] = &#123; &#123; <span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span> &#125;,&#123; <span class="number">5</span>,<span class="number">6</span>,<span class="number">7</span>,<span class="number">8</span> &#125; &#125;;</span><br><span class="line">	<span class="built_in">vector</span>&lt; <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt; ver(<span class="number">2</span>,<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;(<span class="number">4</span>));<span class="comment">//vector初始化</span></span><br><span class="line">	<span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">2</span>;i++) </span><br><span class="line">	&#123;</span><br><span class="line">		<span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; <span class="number">4</span>; j++)</span><br><span class="line">		&#123;</span><br><span class="line">			ver[i][j] = a[i][j];</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">int</span> target = <span class="number">4</span>;</span><br><span class="line">	<span class="keyword">bool</span> is_existed = findItem_quick(ver,target);</span><br><span class="line"><span class="comment">//	bool is_existed = findItem(ver,target);</span></span><br><span class="line">	<span class="built_in">cout</span> &lt;&lt; is_existed &lt;&lt; endl;</span><br><span class="line">	system(<span class="string">"Pause"</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    </entry>
    
    <entry>
      <title><![CDATA[剑指offer-字符串替换与常规问题]]></title>
      <url>http://bupt2014140518.github.io/2015/10/07/%E5%89%91%E6%8C%87offer-%E5%AD%97%E7%AC%A6%E4%B8%B2%E6%9B%BF%E6%8D%A2%E4%B8%8E%E5%B8%B8%E8%A7%84%E9%97%AE%E9%A2%98/</url>
      <content type="html"><![CDATA[<p>主要是考查char的使用，注意指针、变量等的区别联系~<br><img src="http://7xn88r.com1.z0.glb.clouddn.com/Tuscany-Italy.jpg" alt="Italy"><br><a id="more"></a></p>
<h3 id="问题描述">问题描述</h3><p>请实现一个函数，将一个字符串中的空格替换成“%20”。例如，当字符串为We Are Happy.则经过替换之后的字符串为We%20Are%20Happy。</p>
<h3 id="代码">代码</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#include &lt;iostream&gt;</span></span><br><span class="line"><span class="comment">#include &lt;string&gt;</span></span><br><span class="line">using namespace std;</span><br><span class="line">void replaceSpace(char *str, int length)</span><br><span class="line">&#123;</span><br><span class="line">	int i = <span class="number">0</span>, j = length;</span><br><span class="line">	<span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; length; i++) &#123;</span><br><span class="line">		<span class="keyword">if</span> (str[i] == <span class="string">' '</span>)</span><br><span class="line">			j += <span class="number">2</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">for</span> (i = length - <span class="number">1</span>; i &gt;= <span class="number">0</span>; i--) &#123;</span><br><span class="line">		<span class="keyword">if</span> (str[i] == <span class="string">' '</span>) &#123;</span><br><span class="line">			str[--j] = <span class="string">'0'</span>;</span><br><span class="line">			str[--j] = <span class="string">'2'</span>;</span><br><span class="line">			str[--j] = <span class="string">'%'</span>;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">else</span> &#123;</span><br><span class="line">			str[--j] = str[i];</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">void <span class="function"><span class="title">main</span></span>()</span><br><span class="line">&#123;</span><br><span class="line">	char <span class="built_in">test</span>[<span class="number">30</span>] = <span class="string">"We are Happy"</span>; //这里之所以写<span class="number">30</span>，是因为替换之后，长度会扩展，避免溢出，需要长度够长，</span><br><span class="line">	//如果不是这样，估计只能用string返回的方式</span><br><span class="line">    replaceSpace(<span class="built_in">test</span>, strlen(<span class="built_in">test</span>));</span><br><span class="line">	cout &lt;&lt; <span class="built_in">test</span> &lt;&lt; endl;</span><br><span class="line">	char *<span class="built_in">test</span>30 = <span class="string">"We are Happy"</span>;</span><br><span class="line">	string aa = <span class="string">"We are Happy"</span>;</span><br><span class="line">	char *<span class="built_in">test</span>2 = new char[<span class="number">10</span>];</span><br><span class="line">	char <span class="built_in">test</span>10[] = <span class="string">"We are Happy"</span>;</span><br><span class="line">	cout &lt;&lt; <span class="string">"test[30]: "</span> &lt;&lt; sizeof(<span class="built_in">test</span>) &lt;&lt; endl;//输出<span class="number">30</span></span><br><span class="line">	cout &lt;&lt; <span class="string">"test[30]: "</span> &lt;&lt; strlen(<span class="built_in">test</span>) &lt;&lt; endl;//输出<span class="number">12</span></span><br><span class="line">	cout &lt;&lt; <span class="string">"test[]: "</span> &lt;&lt; sizeof(<span class="built_in">test</span>10) &lt;&lt; endl;//输出<span class="number">13</span></span><br><span class="line">	cout &lt;&lt; <span class="string">"test[]: "</span> &lt;&lt; strlen(<span class="built_in">test</span>10) &lt;&lt; endl;//输出<span class="number">12</span></span><br><span class="line">	cout &lt;&lt; <span class="string">"*test: "</span> &lt;&lt; sizeof(<span class="built_in">test</span>30) &lt;&lt; endl;//输出<span class="number">4</span></span><br><span class="line">	cout &lt;&lt; <span class="string">"*test: "</span> &lt;&lt; strlen(<span class="built_in">test</span>30) &lt;&lt; endl;//输出<span class="number">12</span></span><br><span class="line">	cout &lt;&lt; <span class="string">"test string: "</span> &lt;&lt; aa.length()&lt;&lt; endl; //输出<span class="number">12</span></span><br><span class="line">	cout &lt;&lt; <span class="string">"test string: "</span> &lt;&lt; sizeof(aa) &lt;&lt; endl; //输出<span class="number">28</span>，无意义</span><br><span class="line">	cout &lt;&lt; <span class="string">"*test=[]: "</span> &lt;&lt; sizeof(<span class="built_in">test</span>2) &lt;&lt; endl;//输出<span class="number">4</span></span><br><span class="line">	cout &lt;&lt; <span class="string">"*test=[]: "</span> &lt;&lt; strlen(<span class="built_in">test</span>2) &lt;&lt; endl;//输出<span class="number">22</span>，无意义</span><br><span class="line">	</span><br><span class="line">	system(<span class="string">"Pause"</span>);</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="小结">小结</h3><p>（1）此题需注意char单字符用‘’表示，不能用“”；<br>（2）char长度扩展，需要支持，避免越界，当然用string.apend或者pushback同样可以解决问题；<br>（3）关于sizeof、strlen、length()需要弄清楚使用的场景。</p>
]]></content>
    </entry>
    
    <entry>
      <title><![CDATA[面试-不同面额的纸币组合数]]></title>
      <url>http://bupt2014140518.github.io/2015/10/07/%E9%9D%A2%E8%AF%95-%E4%B8%8D%E5%90%8C%E9%9D%A2%E9%A2%9D%E7%9A%84%E7%BA%B8%E5%B8%81%E7%BB%84%E5%90%88%E6%95%B0/</url>
      <content type="html"><![CDATA[<p>主要是考查动态算法解决问题的能力，这是研究生笔试题~<br><img src="http://7xn88r.com1.z0.glb.clouddn.com/Tuscany,%20Italy.jpg" alt="Italy"><br><a id="more"></a></p>
<h3 id="问题描述">问题描述</h3><p>实现有数量不限的面值为100，50，20，10，5，1元的纸币，问要组成N（N&lt;=10^6）共有多少种组合方式? 这个题也可以延伸到好多题目。。。</p>
<h3 id="代码">代码</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#include &lt;iostream&gt;</span></span><br><span class="line"><span class="comment">#include&lt;time.h&gt;  </span></span><br><span class="line">int dynamic_plan(int n, int k[],int i) </span><br><span class="line">&#123;</span><br><span class="line">	int length = sizeof(k) / sizeof(int);</span><br><span class="line">	<span class="keyword">if</span> (n == <span class="number">0</span>)</span><br><span class="line">		<span class="built_in">return</span> <span class="number">1</span>;</span><br><span class="line">	<span class="keyword">if</span> (n&lt;<span class="number">0</span>)</span><br><span class="line">		<span class="built_in">return</span> <span class="number">0</span>;</span><br><span class="line">	<span class="keyword">if</span> (i == <span class="number">5</span>)</span><br><span class="line">		<span class="built_in">return</span> <span class="number">1</span>;</span><br><span class="line">	<span class="keyword">else</span></span><br><span class="line">		<span class="built_in">return</span> dynamic_plan(n - k[i], k, i) + dynamic_plan(n, k, i + <span class="number">1</span>);// 时间复杂度为O(n)</span><br><span class="line">&#125;</span><br><span class="line">int general(int n)</span><br><span class="line">&#123;</span><br><span class="line">	int count = <span class="number">0</span>;</span><br><span class="line">	int kc[] = &#123; n / <span class="number">100</span>,n / <span class="number">50</span>,n / <span class="number">20</span>,n / <span class="number">10</span>,n / <span class="number">5</span>,n &#125;;</span><br><span class="line">	<span class="keyword">for</span> (int i1 = <span class="number">0</span>; i1 &lt;= n / <span class="number">100</span>; i1++) &#123;</span><br><span class="line">		<span class="keyword">for</span> (int i2 = <span class="number">0</span>; i2 &lt;= (n - i1 * <span class="number">100</span>) / <span class="number">50</span>; i2++) &#123;</span><br><span class="line">			<span class="keyword">for</span> (int i3 = <span class="number">0</span>; i3 &lt;= (n - i1 * <span class="number">100</span> - i2 * <span class="number">50</span>) / <span class="number">20</span>; i3++) &#123;</span><br><span class="line">				<span class="keyword">for</span> (int i4 = <span class="number">0</span>; i4 &lt;= (n - i1 * <span class="number">100</span> - i2 * <span class="number">50</span> - i3 * <span class="number">20</span>) / <span class="number">10</span>; i4++) &#123;</span><br><span class="line">					<span class="keyword">for</span> (int i5 = <span class="number">0</span>; i5 &lt;= (n - i1 * <span class="number">100</span> - i2 * <span class="number">50</span> - i3 * <span class="number">20</span> - i4 * <span class="number">10</span>) / <span class="number">5</span>; i5++) &#123;</span><br><span class="line">						<span class="keyword">for</span> (int i6 = <span class="number">0</span>; i6 &lt;= n - i1 * <span class="number">100</span> - i2 * <span class="number">50</span> - i3 * <span class="number">20</span> - i4 * <span class="number">10</span> - i5 * <span class="number">5</span>; i6++) &#123;</span><br><span class="line">							<span class="keyword">if</span> (i1 * <span class="number">100</span> + i2 * <span class="number">50</span> + i3 * <span class="number">20</span> + i4 * <span class="number">10</span> + i5 * <span class="number">5</span> + i6 == n)</span><br><span class="line">								count++;</span><br><span class="line">						&#125;</span><br><span class="line">					&#125;</span><br><span class="line">				&#125;</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="built_in">return</span> count;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">void <span class="function"><span class="title">main</span></span>()</span><br><span class="line">&#123;</span><br><span class="line">	int n = <span class="number">0</span>,num=<span class="number">0</span>;</span><br><span class="line">	clock_t start, finish;</span><br><span class="line">	double totaltime;</span><br><span class="line">	start = clock();</span><br><span class="line">	std::cin &gt;&gt; n;</span><br><span class="line">	int k[] = &#123;<span class="number">100</span>,<span class="number">50</span>,<span class="number">20</span>,<span class="number">10</span>,<span class="number">5</span>,<span class="number">1</span>&#125;;</span><br><span class="line">	int length = sizeof(k)/sizeof(int);</span><br><span class="line">	start = clock();</span><br><span class="line">	num = dynamic_plan(n, k, <span class="number">0</span>);//动态规划（递归，当n比较大的时候时间花费少）</span><br><span class="line">	std::cout &lt;&lt; num &lt;&lt; std::endl;</span><br><span class="line">	finish = clock();</span><br><span class="line">	totaltime = (double)(finish - start) / CLOCKS_PER_SEC;</span><br><span class="line">	std::cout &lt;&lt; <span class="string">"动态规划的运行时间为"</span> &lt;&lt; totaltime &lt;&lt; <span class="string">"秒！"</span> &lt;&lt; std::endl;	</span><br><span class="line">	start = clock();</span><br><span class="line">	num = general(n);//搜索（简单粗暴，当n比较小的时候时间花费长）</span><br><span class="line">	std::cout &lt;&lt; num &lt;&lt; std::endl;</span><br><span class="line">	finish = clock();</span><br><span class="line">	totaltime = (double)(finish - start) / CLOCKS_PER_SEC;</span><br><span class="line">	std::cout &lt;&lt; <span class="string">"粗暴搜索的运行时间为"</span> &lt;&lt; totaltime &lt;&lt; <span class="string">"秒！"</span> &lt;&lt; std::endl;</span><br><span class="line">	system(<span class="string">"Pause"</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
    </entry>
    
    <entry>
      <title><![CDATA[面试-抛球问题]]></title>
      <url>http://bupt2014140518.github.io/2015/10/07/%E9%9D%A2%E8%AF%95-%E6%8A%9B%E7%90%83%E9%97%AE%E9%A2%98/</url>
      <content type="html"><![CDATA[<p>主要是注意细节的处理，这是研究生笔试题~<br><img src="http://7xn88r.com1.z0.glb.clouddn.com/Yellowstone%20National%20Park,%20U.S..jpg" alt="US"><br><a id="more"></a></p>
<h3 id="问题描述">问题描述</h3><p>有四个孩子，站到分别四层楼，往下抛小球，每次球落下后，再次弹起的高度是上一次的一半，求四个球到完全落到地面，弹不起来之后，一共走了多远。</p>
<h3 id="代码">代码</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#include &lt;iostream&gt;</span></span><br><span class="line">using namespace std;</span><br><span class="line">void <span class="function"><span class="title">main</span></span>()</span><br><span class="line">&#123;</span><br><span class="line"></span><br><span class="line">    int floor[<span class="number">4</span>];</span><br><span class="line">    int single = <span class="number">0</span>, total = <span class="number">0</span>,j;</span><br><span class="line">    <span class="keyword">for</span> (int i = <span class="number">0</span>; i &lt; <span class="number">4</span>; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        cin &gt;&gt; floor[i];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span> (int i = <span class="number">0</span>; i &lt; <span class="number">4</span>; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        j = floor[i];</span><br><span class="line">        single = j;</span><br><span class="line">        <span class="keyword">while</span> (j &gt; <span class="number">0</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            single += (j / <span class="number">2</span>)*<span class="number">2</span>;</span><br><span class="line">            j /= <span class="number">2</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        total += single;</span><br><span class="line">    &#125;</span><br><span class="line">    cout &lt;&lt; total &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    </entry>
    
    <entry>
      <title><![CDATA[面试-数组元素组合]]></title>
      <url>http://bupt2014140518.github.io/2015/10/07/%E9%9D%A2%E8%AF%95-%E6%95%B0%E7%BB%84%E5%85%83%E7%B4%A0%E7%BB%84%E5%90%88/</url>
      <content type="html"><![CDATA[<p>主要是数组元素各种组合的处理，这是研究生笔试题~<br><img src="http://7xn88r.com1.z0.glb.clouddn.com/Yellowstone%20National%20Park,%20U.S1..jpg" alt="Nation Park"><br><a id="more"></a></p>
<h3 id="问题描述">问题描述</h3><p>给定一个数组arr和limit值，分两次从数组取出一个元素（这两个元素有可能相同）分别为x，y，使得s=x+y，求出s的最大值且不超过limit值。</p>
<h3 id="代码">代码</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#include &lt;iostream&gt;</span></span><br><span class="line">using namespace std;</span><br><span class="line">void <span class="function"><span class="title">main</span></span>()</span><br><span class="line">&#123;</span><br><span class="line">     int arr[] = &#123;<span class="number">2</span>,<span class="number">4</span>,<span class="number">6</span>&#125;;</span><br><span class="line">    int <span class="built_in">limit</span> = <span class="number">7</span>;</span><br><span class="line">    int max = <span class="number">0</span>, s = <span class="number">0</span>, x = <span class="number">0</span>, y = <span class="number">0</span>;</span><br><span class="line">    int length = sizeof(arr)/sizeof(int);</span><br><span class="line">   <span class="keyword">for</span> (int i = <span class="number">0</span>; i &lt; length;i++)</span><br><span class="line">  &#123;</span><br><span class="line">      x = arr[i];</span><br><span class="line">     <span class="keyword">for</span> (int j = <span class="number">0</span>; j &lt; length;j++)</span><br><span class="line">     &#123;</span><br><span class="line">          y = arr[j];</span><br><span class="line">          s = x + y;</span><br><span class="line">          <span class="keyword">if</span> (s&lt;=<span class="built_in">limit</span> &amp;&amp; max&lt;=s)</span><br><span class="line">          &#123;</span><br><span class="line">              max = s;</span><br><span class="line">          &#125;</span><br><span class="line">     &#125;</span><br><span class="line"></span><br><span class="line"> &#125;</span><br><span class="line"> cout &lt;&lt; max &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    </entry>
    
    <entry>
      <title><![CDATA[面试题-熊分苹果]]></title>
      <url>http://bupt2014140518.github.io/2015/10/07/%E9%9D%A2%E8%AF%95%E9%A2%98-%E7%86%8A%E5%88%86%E8%8B%B9%E6%9E%9C/</url>
      <content type="html"><![CDATA[<p>主要是两个思路，这是研究生笔试题~<br><img src="http://7xn88r.com1.z0.glb.clouddn.com/Yellowstone%20National%20Park,%20U.S2..jpg" alt="YellowStone"><br><a id="more"></a></p>
<h2 id="问题描述">问题描述</h2><p>  有1堆苹果共 m 个，由 n 只熊/猴子按个数平均分配。每次到达苹果堆放地的猴子只有1只，而且每个猴子都会平均分 1 次苹果。第1个到达的猴子将苹果平均分成 n 等份，但发现多 k ( k &lt; n )个，于是，将多余的k个扔掉，然后拿走其中的1等份。第 2 个猴子同样将剩余的苹果又分成 n 等份，也发现多 k 个，并同样将多余的 k 个扔掉，然后拿走其中1等份。之后的每个猴子都这样（将剩余的苹果又分成 n 等份，也发现多 k 个，并将多余的 k 个扔掉，然后拿走其中1等份）。假设最后的猴子分配后至少可以拿走1个苹果，请根据输入的 n 和 k值，计算最小的 m。</p>
<h2 id="代码">代码</h2><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#include &lt;iostream&gt;</span></span><br><span class="line">int <span class="function"><span class="title">main</span></span>()</span><br><span class="line">&#123;</span><br><span class="line">   /*小熊分苹果的问题</span><br><span class="line">   *主要有两个思路：（<span class="number">1</span>）从每次分配的每份的个数最少进行倒退；（<span class="number">2</span>）从苹果总数最少开始正推</span><br><span class="line">   *本题的思路是（<span class="number">1</span>）</span><br><span class="line">   */</span><br><span class="line">   int n,k=<span class="number">1</span>,current_app=<span class="number">0</span>;//n代表熊的个数，k代表每次分配n份后，多余的苹果数，current_app代表每次小熊分完走之后剩余数</span><br><span class="line">   bool flag = <span class="literal">false</span>;</span><br><span class="line">   std::cin &gt;&gt; n;</span><br><span class="line">   int j = <span class="number">1</span>;//j代表最后一个猴子分配之后，每份的个数，最少从<span class="number">1</span>开始</span><br><span class="line">   <span class="keyword">for</span> (;;j++)</span><br><span class="line">   &#123;</span><br><span class="line">     current_app = n*j + k;</span><br><span class="line">     <span class="keyword">for</span> (int i = <span class="number">1</span>; i &lt; n; i++)//注意：这里是循环n-<span class="number">1</span>次，因为最后一次是满足的</span><br><span class="line">     &#123; </span><br><span class="line">        <span class="keyword">if</span> (current_app % (n-<span class="number">1</span>) == <span class="number">0</span>)</span><br><span class="line">        &#123;</span><br><span class="line">           current_app = current_app * n / (n - <span class="number">1</span>) + k;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">        &#123;</span><br><span class="line">           <span class="built_in">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">       <span class="keyword">if</span> (i == n-<span class="number">1</span>)</span><br><span class="line">       &#123;</span><br><span class="line">          flag = <span class="literal">true</span>;</span><br><span class="line">          <span class="built_in">break</span>;</span><br><span class="line">       &#125;</span><br><span class="line">     &#125;</span><br><span class="line">     <span class="keyword">if</span> (flag == <span class="literal">true</span>) </span><br><span class="line">     &#123;</span><br><span class="line">        <span class="built_in">break</span>;</span><br><span class="line">     &#125;</span><br><span class="line">   &#125;</span><br><span class="line">   std::cout &lt;&lt; current_app &lt;&lt; <span class="string">" "</span> &lt;&lt; j &lt;&lt; std::endl;</span><br><span class="line">   system(<span class="string">"pause"</span>);</span><br><span class="line">   <span class="built_in">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    </entry>
    
  
  
</search>
